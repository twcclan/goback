// Code generated by protoc-gen-go. DO NOT EDIT.
// source: file.proto

package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// this contains file metadata, which can be different
// accross backups, even if file content is the same
type FileInfo struct {
	Name      string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Mode      uint32 `protobuf:"varint,2,opt,name=mode" json:"mode,omitempty"`
	User      string `protobuf:"bytes,3,opt,name=user" json:"user,omitempty"`
	Group     string `protobuf:"bytes,4,opt,name=group" json:"group,omitempty"`
	Timestamp int64  `protobuf:"varint,5,opt,name=timestamp" json:"timestamp,omitempty"`
	Size      int64  `protobuf:"varint,6,opt,name=size" json:"size,omitempty"`
	Tree      bool   `protobuf:"varint,7,opt,name=tree" json:"tree,omitempty"`
}

func (m *FileInfo) Reset()                    { *m = FileInfo{} }
func (m *FileInfo) String() string            { return proto1.CompactTextString(m) }
func (*FileInfo) ProtoMessage()               {}
func (*FileInfo) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

func (m *FileInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FileInfo) GetMode() uint32 {
	if m != nil {
		return m.Mode
	}
	return 0
}

func (m *FileInfo) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *FileInfo) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *FileInfo) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *FileInfo) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *FileInfo) GetTree() bool {
	if m != nil {
		return m.Tree
	}
	return false
}

type File struct {
	Parts []*FilePart `protobuf:"bytes,1,rep,name=parts" json:"parts,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto1.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1} }

func (m *File) GetParts() []*FilePart {
	if m != nil {
		return m.Parts
	}
	return nil
}

type FilePart struct {
	Offset uint64 `protobuf:"varint,1,opt,name=offset" json:"offset,omitempty"`
	Length uint64 `protobuf:"varint,2,opt,name=length" json:"length,omitempty"`
	Ref    *Ref   `protobuf:"bytes,3,opt,name=ref" json:"ref,omitempty"`
}

func (m *FilePart) Reset()                    { *m = FilePart{} }
func (m *FilePart) String() string            { return proto1.CompactTextString(m) }
func (*FilePart) ProtoMessage()               {}
func (*FilePart) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{2} }

func (m *FilePart) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *FilePart) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *FilePart) GetRef() *Ref {
	if m != nil {
		return m.Ref
	}
	return nil
}

func init() {
	proto1.RegisterType((*FileInfo)(nil), "proto.FileInfo")
	proto1.RegisterType((*File)(nil), "proto.File")
	proto1.RegisterType((*FilePart)(nil), "proto.FilePart")
}

func init() { proto1.RegisterFile("file.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 241 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x44, 0x8f, 0xcd, 0x4a, 0xc4, 0x30,
	0x14, 0x85, 0x89, 0xfd, 0x71, 0x7a, 0x07, 0x11, 0x82, 0x48, 0x90, 0x59, 0x84, 0x82, 0x90, 0x8d,
	0xb3, 0x18, 0xdf, 0x41, 0x70, 0x27, 0x77, 0xe5, 0xb6, 0xe2, 0xcd, 0x58, 0x68, 0x9b, 0x92, 0x64,
	0x36, 0x3e, 0x8e, 0x4f, 0x2a, 0xf7, 0xa6, 0x30, 0xab, 0x9e, 0xf3, 0x9d, 0x92, 0xe4, 0x03, 0xf0,
	0xe3, 0x44, 0xc7, 0x35, 0x86, 0x1c, 0x74, 0x23, 0x9f, 0xa7, 0x2e, 0x92, 0x2f, 0xa4, 0xff, 0x53,
	0xb0, 0x7b, 0x1b, 0x27, 0x7a, 0x5f, 0x7c, 0xd0, 0x1a, 0xea, 0x65, 0x98, 0xc9, 0x28, 0xab, 0x5c,
	0x87, 0x92, 0x99, 0xcd, 0xe1, 0x9b, 0xcc, 0x8d, 0x55, 0xee, 0x0e, 0x25, 0x33, 0xbb, 0x24, 0x8a,
	0xa6, 0x2a, 0xff, 0x71, 0xd6, 0x0f, 0xd0, 0x9c, 0x63, 0xb8, 0xac, 0xa6, 0x16, 0x58, 0x8a, 0x3e,
	0x40, 0x97, 0xc7, 0x99, 0x52, 0x1e, 0xe6, 0xd5, 0x34, 0x56, 0xb9, 0x0a, 0xaf, 0x80, 0xcf, 0x49,
	0xe3, 0x2f, 0x99, 0x56, 0x06, 0xc9, 0xcc, 0x72, 0x24, 0x32, 0xb7, 0x56, 0xb9, 0x1d, 0x4a, 0xee,
	0x5f, 0xa0, 0xe6, 0x37, 0xea, 0x67, 0x68, 0xd6, 0x21, 0xe6, 0x64, 0x94, 0xad, 0xdc, 0xfe, 0x74,
	0x5f, 0x1c, 0x8e, 0xbc, 0x7d, 0x0c, 0x31, 0x63, 0x59, 0xfb, 0xcf, 0xa2, 0xc4, 0x48, 0x3f, 0x42,
	0x1b, 0xbc, 0x4f, 0x94, 0x45, 0xaa, 0xc6, 0xad, 0x31, 0x9f, 0x68, 0x39, 0xe7, 0x1f, 0x11, 0xab,
	0x71, 0x6b, 0xfa, 0x00, 0x55, 0x24, 0x2f, 0x66, 0xfb, 0x13, 0x6c, 0x17, 0x20, 0x79, 0x64, 0xfc,
	0xd5, 0x4a, 0x7f, 0xfd, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x7c, 0xf4, 0xc2, 0x51, 0x54, 0x01, 0x00,
	0x00,
}
